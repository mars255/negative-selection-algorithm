#include <iostream>
#include <vector>
#include <cmath>
#include <random>
#include <fstream>
#include "detector.h"
#include <omp.h>
#include <cstddef>
#include <cstdio>
#include <sstream>
#include <string>

/*
 *@brief: calculates the Euclidean distance between the elements of two vectors
 * */
template <typename T>
double euclidean_distance(const std::vector<T>& vec1, const std::vector<T>& vec2) {
    T sum = 0;
    for (size_t i = 0; i < vec1.size(); ++i) {
        sum += std::abs(vec1[i] - vec2[i]); // Compute the absolute difference and accumulate
    }
    return sum / vec1.size(); // Return the average difference as Euclidean distance
}

/*
 *@brief: Generates a valid detector by creating a random detector and checking if it meets the threshold.
 *        If not, it keeps regenerating the detector until it meets the threshold.
 * */
template <typename T>
std::vector<T> generate_valid_detector(const std::vector<std::vector<T>>& self_data, size_t size, T lower_bound, T upper_bound, double threshold) {
    // Generate a random detector
    std::vector<T> current_detector = generate_random_detector(size, lower_bound, upper_bound);

    // Keep generating a new detector until it's valid
    while (!check_detector(self_data, current_detector, threshold)) {
        current_detector.clear();
        current_detector = generate_random_detector(size, lower_bound, upper_bound);
    }
    return current_detector;
}

/*
 *@brief: Generates multiple valid detectors using OpenMP for parallelization.
 *        Each detector is generated by calling the generate_valid_detector function.
 *        The result is a list of detectors.
 * */
template <typename T>
std::vector<std::vector<T>> generate_detectors(const std::vector<std::vector<T>>& self_data, double threshold, size_t num_generators, T lower_bound, T upper_bound) {
    std::vector<std::vector<T>> detectors;
    detectors.reserve(num_generators); // Reserve space for the detectors
    int total_detectors = 0;

    // Parallelize the loop using OpenMP
    #pragma omp parallel for
    for (size_t i = 0; i < num_generators; ++i) {
        // Generate a valid detector
        std::vector<T> new_detector = generate_valid_detector(self_data, self_data[0].size(), lower_bound, upper_bound, threshold);
        
        // Critical section to ensure thread-safe access to the shared 'detectors' vector
        #pragma omp critical
        {
            detectors.emplace_back(new_detector); // Add the new detector to the list
            ++total_detectors;
        }

        // Optionally print the progress (can be removed if too verbose)
        #pragma omp critical
        {
            std::cout << total_detectors << " detectors added!" << "\n";
        }
    }

    return detectors;
}

/*
 *@brief: Generates a random number between a lower and upper bound.
 *        Supports both integral and floating-point types.
 * */
template <typename T>
T generate_random(T lower, T upper) {
    // Seed with a real random value
    std::random_device rd;
    std::mt19937 gen(rd());

    if constexpr (std::is_integral<T>::value) {
        // Integer distribution for integral types
        std::uniform_int_distribution<T> dist(lower, upper);
        return dist(gen);
    } else if constexpr (std::is_floating_point<T>::value) {
        // Real distribution for floating-point types
        std::uniform_real_distribution<T> dist(lower, upper);
        return dist(gen);
    } else {
        return 0; // Return 0 for unsupported types
    }
}

/*
 *@brief: Generates a random detector of a given size with random values between lower_bound and upper_bound.
 * */
template <typename T>
std::vector<T> generate_random_detector(size_t size, T lower_bound, T upper_bound) {
    std::vector<T> detector;
    detector.reserve(size);
    for (size_t i = 0; i < size; ++i) {
        detector.emplace_back(generate_random(lower_bound, upper_bound)); // Add random value to the detector
    }
    return detector;
}

/*
 *@brief: Checks if a detector is valid by comparing its Euclidean distance to each data point in self_data.
 *        A detector is valid if the distance to all data points is greater than the threshold.
 * */
template <typename T>
bool check_detector(const std::vector<std::vector<T>>& self_data, const std::vector<T>& detector, double threshold) {
  bool valid = true;

  // Iterate through the data points and check the Euclidean distance
  for (auto& data_point : self_data) {
    if (euclidean_distance(data_point, detector) < threshold) {
      valid = false; // If any data point is too close to the detector, it's invalid
      break;
    }  
  }
  return valid;
}

/*
 *@brief: Saves the generated detectors to a file in CSV format.
 *        Each row corresponds to a detector, with its values separated by commas.
 * */
template <typename T>
int print_generators_to_file(const std::vector<std::vector<T>>& generators, const std::string& file_path) {
    std::ofstream file;
    file.open(file_path); // Open the file for writing
    for (const auto& generator : generators) {
        for (size_t i = 0; i < generator.size(); ++i) {
            file << generator[i];
            if (i != generator.size() - 1) {
                file << ","; // Add a comma if it's not the last element
            }
        }
        file << "\n"; // Add a newline after each detector
    }
    file.close();
    return 0; // Return 0 to indicate success
}

/*
 *@brief: Reads data from a CSV file and stores it in the self_data vector.
 *        Each line of the file represents a new data point.
 * */
template <typename T>
int read_self_data(const std::string file_path, std::vector<std::vector<T>>& self_data, size_t& size) {
  std::ifstream file(file_path);
  if (!file.is_open()) {
    std::cerr << "File does not exist!" << std::endl;
    return 1; // Return an error if the file cannot be opened
  }

  std::string line;
  
  while (getline(file, line)) {
    std::vector<T> new_data;
    std::stringstream ss(line);
    std::string number_str;

    T number;

    while (getline(ss, number_str, ',')) {
        std::istringstream(number_str) >> number; // Convert each value to type T
        new_data.push_back(number); // Add the number to the new data vector
    }
    self_data.push_back(new_data); // Add the new data point to the self_data vector
  }

  if (self_data.empty()) {
    size = 0; // If no data is read, set size to 0
  } else {
    size = self_data[0].size(); // Set size to the number of elements in the first data point
  }
  return 0; // Return 0 to indicate success
}
